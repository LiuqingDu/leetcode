/*
 * @lc app=leetcode.cn id=665 lang=java
 *
 * [665] 非递减数列
 */

// @lc code=start
class Solution {
    public boolean checkPossibility(int[] nums) {
        // 第一感觉是遍历一下看有多少个下降,超过一个就不行
        // 但对于这个数组 3,4,2,3 虽然只有一个下降但不满足
        // 这里如果把 4 修改为比 2 小,又还需要比前面的 3 大
        // 如果把 2 修改成比 4 大,又要比后面的 3 小
        // 注意除了是否只有一个下降,修改的数字还需要跟它前后的数字比较,
        // 使得存在那个满足条件的修改后的数字
        // 观察下面几个情况,寻找数字的限制条件
        // 1:   4,2,5
        // 2:   1,4,2,5
        // 3:   3,4,2,5
        // 这三种情况都是 2 破坏了递增关系,它前面都是 4
        // 都以 2 为观察对象, 它的索引为 i
        // 尽量优先修改 i 之前的数字, 因为 i 之后的数字还不知道什么情况
        // 对于情况 1, 修改 4 的话无需进一步考虑,因为 4 前面没有数字了, 只需要让他跟 i 维持递增即可
        // 也就是 i=1 的时候, 直接修改 nums[0] 即可
        // 对于情况 2, 修改 4 的时候还需要保证它要大于等于它之前的数字
        // 也就是修改 nums[i-1], 且要大于等于 nums[i-2]
        // 对于情况 3, 修改 4 已经无法满足了, 那么只能修改 i , 确保它和 i+1 的关系, 令 nums[i] = nums[i-1] 即可
        // 也就是使得 nums[i] 小于等于 nums[i+1]

        // 记录下降次数
        int count = 0;

        // 从第二个开始, 因为优先修改 nums[i-1], 其次修改 nums[i]
        for (int i = 1; i < nums.length; i++) {
            // 出现下降
            if (nums[i] < nums[i - 1]) {
                // 如果 i==1 也就是无需考虑 i-1 之前的
                // 或者 nums[i-2] 小于等于 nums[i] 也就是可以修改 nums[i-1] 的
                if (i == 1 ||  nums[i - 2] <= nums[i]) {
                    nums[i - 1] = nums[i];
                } else {
                    // 否则修改 nums[i]
                    nums[i] = nums[i - 1];
                }
                // 记录下降次数
                count++;
                // 超过一次就不行
                if (count > 1) {
                    return false;
                }
            }
        }
        return true;
    }
}
// @lc code=end

