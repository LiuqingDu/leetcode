/*
 * @lc app=leetcode.cn id=50 lang=java
 *
 * [50] Pow(x, n)
 */

// @lc code=start
class Solution {
    
    // 对于任意一个正数n，它可以由多个2的幂相加得到
    // 比如3 = 2**1 + 2**0，7 = 2**2 + 2**1 + 2**0
    // 假设这样的和表示为n = k1 + k2 + k3...
    // k1, k2, k3都是2的幂，不难发现，这些k值实际上是n的二进制当中“1”的所在位
    // 比如3的二进制为11，就是从右往左第0位和第1位是1，
    // 比如12的二进制位1100 = 2**2 + 2**3，从右往左的2位和3位是1
    // 那么根据n的二进制中哪些位置上有1，就可以找到这样的2次幂之和来表示n
    // 那么原题计算的x**n就可以表示为x**k1 * x**k2 * x**k3 ... (其中k1+k2+k3+..=n)
    // 因为k1, k2, k3实际是n的二进制中为1的位置
    // 那么我们从n的二进制右侧往左，每走一位就把x乘一下计算一个幂(x**k)，然后如果
    // 这个位置是1，就把这个幂（x**k1)乘到结果中，如此反复，下一次遇到1时这个幂就是x**k2,
    // 也相应地乘到结果中
    // 最终得到x**k1 * x**k2 *... = x**n

    public double myPow(double x, int n) {
        // 有一个测试用例是-2**31, 取反后是2**31, 刚好超出int范围(2**31 - 1)，
        // 所以需要转为long防止溢出
        long N = n;
        return N >= 0 ? quickMulti(x, N) : 1/quickMulti(x, -N);

    }

    private double quickMulti(double x, long N) {
        double res = 1.0;
        double k = x;

        while (N > 0) {
            // 如果最后一位是1
            if (N % 2 == 1) {
                // 把这个幂乘到结果里
                res *= k;
            }
            // 无论是否乘了，都是读了一位，需要算下一个幂（k值），也就是继续平方
            k *= k;
            // 把二进制最后一位舍弃掉
            N /= 2;
        }

        return res;
    }
}
// @lc code=end

