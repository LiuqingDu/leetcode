/*
 * @lc app=leetcode.cn id=424 lang=java
 *
 * [424] 替换后的最长重复字符
 */

// @lc code=start
class Solution {
    public int characterReplacement(String s, int k) {
        // 滑动窗口
        // 但是这个窗口是不会收缩的，窗口表示它历史上曾经出现过的最大的窗口
        // 因为本题是要算可能得最长的串，那么窗口不需要收缩，只能扩张
        // 若右边元素进入窗口后不再满足条件，那么窗口不再扩张
        // 将窗口尺寸不变向右平移（当然这里需要更新窗口内进入元素和删除左侧元素）
        // 移动一位后检查窗口是否满足条件，如果满足，则停止平移继续尝试向右扩张
        // 如果不满足，则继续平移，此时窗口宽度表示曾经历史上最大的窗口
        // 除非未来还出现至少满足当前窗口的情况，否则都可以忽略并继续平移
        // 假设 k=0 来先考虑一下
        // 此时其实就是找最长的同字符子串
        // 比如 AABBB
        // 窗口先扩张到 AA
        // 此时不能继续扩张，那么久开始平移
        // A[AB]BB -> AA[BB]B
        // 第一次平移，窗口内不符合要求，继续平移，窗口内是 BB，符合，
        // 然后尝试扩张窗口
        // AA[BBB]
        // 到达尾部，窗口就是最长串
        // 如果 k 不为 0，那么就是说允许窗口内有 k 个字符进行变换
        // 那么假设窗口内同字符最多的数量是 x，窗口内总共有 n 个字符
        // 那么如果 x+k >= n，则窗口内可以满足条件
        // 也就是说，窗口内保留字符最多的那个，剩下的字符如果数量不大于 k，那么就可以替换并满足要求
        // 从而窗口内就是满足的，就可以继续尝试扩张

        // 记录窗口内每个字符出现的次数
        int[] map = new int[26];
        char[] chars = s.toCharArray();
        int left = 0;
        int right = 0;
        // 历史上窗口内出现的同字符次数的最大值
        // 因为窗口会扩张到用掉所有的机会，也就是 k 会全部被用掉
        // 那么最大窗口的长度应当是 historyCharMax + k
        // 除非 k 还没有用完就已经到字符串末尾了，那么此时 其实是字符串长度小于 k 的
        // 题目已经保证长度不小于 k 了，那么后面这种情况不会出现
        int historyCharMax = 0;
        for (right = 0; right < chars.length; right++) {
            // 每轮先尝试扩张窗口，扩张完了以后检查新进来的元素是否让当前窗口不满足条件了
            // 如果不满足，那么本轮不应该扩张，而是平移
            // 在已经扩张的情况下，删除左边元素，就相当于本轮是平移了
            int ch = chars[right] - 'A';
            map[ch]++;
            // 更新最大同字符数量
            historyCharMax = Math.max(historyCharMax, map[ch]);
            // 当窗口内的字符替换次数超过 `k` 时，需要移动左边界缩小窗口
            // 也就是当前窗口长度减去可替换次数 k，如果剩余的字符数量还大于最大同字符数量
            // 就意味着用完 k 次也不能替换成同字符
            // 实际上也就是新进的字符并不是charmax的那个字符
            // 新进字符导致窗口内 k 不够用了，所以需要删去窗口左边元素
            // 删除左边元素其实就是相当于本轮操作是平移，而不是扩张
            if (right - left + 1 - k > historyCharMax) {
                map[chars[left] - 'A']--;
                left++;
            }
        }
        // right 指向字符串尾部的右边，也就是超出了一位，所以这里 right-left 就可以了
        return right - left;
    }
}
// @lc code=end

