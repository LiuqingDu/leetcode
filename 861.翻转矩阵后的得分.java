/*
 * @lc app=leetcode.cn id=861 lang=java
 *
 * [861] 翻转矩阵后的得分
 */

// @lc code=start
class Solution {
    public int matrixScore(int[][] grid) {
        // 首先, 注意一个规律是, 对于一个翻转的方案, 打乱每一步的顺序不影响最终结果
        // 为了使最终得分最大, 那么要每一行的首位都为1
        // 这个可以通过行翻转来实现,把首位为0的行翻转
        // 然后就只能进行列翻转了
        // 从第二列开始,如果某一列1的个数小于0的个数, 那么就翻转这一列, 使得1更多
        // 最后计算总分的时候,实际上不需要真的翻转,只需要计算每一列的贡献即可
        // 比如最左边一列,每一个1的贡献是2^(n-1), n是列数,m是行数, 
        // 总贡献就是 m * 2^(n-1)
        // 以此类推, 对于第i列, 统计1和0的个数,取最大值,
        // 最大值就是最终这一列1的数量,然后计算贡献,累加到最终结果上

        // m是行数, n是列数
        int m = grid.length, n = grid[0].length;
        int result = 0;
        result += m * (1 << (n - 1)); // 第一列的贡献, 每一行都为1, 所以贡献是m * 2^(n-1)

        // 从第二列开始,计算每一列的贡献
        // 这里要假装我们可能已经翻转了一些行
        // 如果每一行的第一位是0,那么这行是要翻转的,在这里计算1的数量的时候要考虑到
        // j表示第几列, 从1开始
        for (int j = 1; j < n; j++) {
            // 统计第j列1的个数
            int nOnes = 0;
            // 遍历第j列的每一个元素,从顶部第一个元素开始
            // i表示第几行,从0开始
            for (int i = 0; i < m; i++) {
                if (grid[i][0] == 1) {
                    // 如果第一列是1, 当前元素不会翻转, 把当前的1的数量加进去
                    nOnes += grid[i][j];
                } else {
                    // 如果第一列是0, 那么当前元素会被翻转,
                    // 所以当前的0会变成1, 当前的1会变成0
                    // 因此, 当前的1的数量应该是1 - grid[i][j]
                    nOnes += 1 - grid[i][j];
                }
            }
            int k = Math.max(nOnes, m - nOnes); // 取最大值, 即当前列1的数量
            result += k * (1 << (n - j - 1)); // 计算当前列的贡献
        }
        return result; // 返回最终得分
    }
}
// @lc code=end

