/*
 * @lc app=leetcode.cn id=204 lang=java
 *
 * [204] 计数质数
 */

// @lc code=start
class Solution {
    // 如果从1到n依次判断每个数字是不是质数比较慢，因为判断这个数是不是质数，需要
    // 判断它是不是能被从2到sqrt(n)之间的数整除，对于每一个n都做一次循环判断会很复杂
    // 可以用排除法，对于2到n这些数字，如果一个数字i是质数，那么2*i, 3*i...就不是质数
    // 可以把这个素数的整数倍都标记为合数
    // 已知2是质数，那么2的倍数都不是质数，3是质数，那么3的倍数就不是质数，
    // 接下来4因为已经不是质数了，继续判断5，7...这样遍历下去
    // 这样实际上是把一个数字i当作因数，然后把以i为因数的所有数字标记为合数，
    // 标记后剩下没有被标记的就是质数

    // 判断一个数是不是质数，需要找到它的因数，这个因数找到sqrt(n)就可以了，
    // 因为如果在[2, sqrt(n)]之间有因数，那么在[sqrt(n), n]之间就有另一个因数与这个因数对应，
    // 如果[2, sqrt(n)]之间没有因数，那么[sqrt(n), n]之间也不会有因数。

    // 标记一个质数的整数倍为合数时，也可以进一步优化，比如标记5的倍数，
    // 标记5x2的时候，这个数实际上已经被2的那一轮的2x5标记过了，同理标记5x3也是被3标记过的
    // 因此标记一个质数i的整数倍时，可以从i*i开始标记
    public int countPrimes(int n) {

        boolean[] isPrime = new boolean[n];
        // 假设所有数字都是质数
        Arrays.fill(isPrime, true);

        // 从2开始遍历到sqrt(n), 把这些数字当作因数，然后去标记以它们为因数的数字
        for (int i = 2; i * i < n; i++) {
            // 如果是质数则标记它的倍数为合数
            // 如果是合数，那么它的倍数已经被它的一个因数标记过了
            if (isPrime[i]) {
                // 从i*i开始标记，因为[2, i*i]之间的数字已经被更小的i标记过了
                for (int j = i * i; j < n; j+=i) {
                    isPrime[j] = false;
                }
            }
        }

        int res = 0;
        // 计算比n小的质数的个数，当n为2的时候，才出现第一个比n小的质数，因此从2开始计算
        for (int i = 2; i < n; i++) {
            if (isPrime[i]) {
                res++;
            }
        }

        return res;
    }
}
// @lc code=end

