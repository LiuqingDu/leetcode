/*
 * @lc app=leetcode.cn id=1752 lang=java
 *
 * [1752] 检查数组是否经排序和轮转得到
 */

// @lc code=start
class Solution {
    public boolean check(int[] nums) {
        // 1. 出现两次以上递减直接返回False；
        // 2. 不出现递减，返回True；
        // 3. 出现一次递减，就看nums的最后一个元素是否不大于第一个元素。
        // 对于 3, 实际上还是要求只能出现一次递减,它通过比较最后一个和第一个元素,
        // 要求它在轮转一位后,原先最后一个元素和第一个元素连接在一起,也不会成为第二个递减
        // 因此可以合并 2 和 3, 通过求余来实现遍历到最后一位时可以跟第一位比较
        // 再结合 1,最终要求就是下降最多出现一次

        // 换一个思路,如果可以通过非递减的轮转得到,那么假设没轮转,就是没有下降
        // 如果轮转了,那么就只有一次下降
        // 因此也可以得出要求的条件是下降最多一次

        int n = nums.length;
        int count = 0;
        for (int i = 0; i < n; i++) {
            // 记录下降次数
            // 通过求余来实现最后一位跟第一位比较
            if (nums[i] > nums[(i + 1) % n]) {
                count += 1;
            }
        }
        // 下降不超过一次即可
        return count <= 1;

    }
}
// @lc code=end

