/*
 * @lc app=leetcode.cn id=486 lang=java
 *
 * [486] 预测赢家
 */

// @lc code=start
class Solution {
    public boolean predictTheWinner(int[] nums) {
        // 动态规划
        // 如果我选择了第 i 个数字，那么意味着我的总和增加了 nums[i]
        // 那么对面就需要从 nums[i+1, j] 中选择
        // 记 dp[i][j] 表示在数组 nums[i, j] 这部分当中
        // 我能获得的最大的分值差，这取决于对方在 nums[i+1, j] 中
        // 对方获得的最大差值，我选择 i 之后能获得的最大差值等于
        // nums[i] - dp[i+1][j]
        // 也就是我选择的这个数字减去对方在剩下的部分当中能获取的最大差值
        // 同样的我也可以选择第 j 个数字，然后两个情况取大值
        // dp[i][j] = max(nums[i] - dp[i+1][j], nums[j] - dp[i][j-1])
        // 其中当 i=j 的时候 dp[i][j] = nums[i]
        // 且 i <= j 因此不需要考虑 i > j

        // 另外当数组长度为偶数时，先手总是可以赢
        // 原因如下：将数字根据索引分为奇数索引组和偶数索引组
        // 比较两个组的数字之和，选更大的那一组作为自己的方案
        // 假设偶数组更大
        // 先手可以选择偶数索引那个数，留下两头都是奇数索引的给对面选择
        // 这样轮到自己又可以选择一个偶数，以此类推可以选择所有的偶数
        // 而迫使对方只有奇数组可以选

        int n = nums.length;
        // 如果数组长度是偶数，先手总能赢
        if (n % 2 == 0) {
            return true;
        }
        
        int[][] dp = new int[n][n];
        
        // 初始化 dp[i][i]，表示单个元素时的得分差
        for (int i = 0; i < n; i++) {
            dp[i][i] = nums[i];
        }

        // 这里的计算顺序需要考虑一下，因为只有一半的数据才会被计算
        // 就是 i <= j 这一半，且是基于 i=j 这条对角线开始计算的
        //   j  0  1  2  3
        // i
        // 0    .  D  E  F
        // 1       .  B  C
        // 2          .  A
        // 3             .
        // 上表中，点(.)表示已知的 i=j 对角线
        // 需要计算的是右上半部分，每一个格子基于它的左边和下边
        // 因此需要按照 A B C D E F 的顺序计算
        // 对于 i = n-1 已经知道了，因此从 n-2 开始
        // 对于 j，应当从 i+1 开始
        
        // 逐步计算区间 dp[i][j]
        for (int i = n - 2; i >= 0; i--) {
            for (int j = i + 1; j < n; j++) {
                dp[i][j] = Math.max(nums[i] - dp[i + 1][j], nums[j] - dp[i][j - 1]);
            }
        }
        
        // 如果最终的分差 >= 0，先手玩家获胜
        return dp[0][n - 1] >= 0;
        
    }
}
// @lc code=end

