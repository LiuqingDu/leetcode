/*
 * @lc app=leetcode.cn id=115 lang=java
 *
 * [115] 不同的子序列
 */

// @lc code=start
class Solution {
    // 动态规划
    // 对于s和t，长度分别是m和n，比较它们的最后一位字符s[n-1]和t[m-1]
    // 如果它们最后一位相同，那么为了从s中找到一个子序列，有两种方案：
    //      1. 使用包含s[n-1]这个字符的子序列，那么这个方案的数量取决于【在s的前n-1个字符里找到子序列等于t的前m-1个字符的方案数】
    //          也就是说，组成这个子序列的最后一位选择s[n-1]这个字符，那么除了这最后一个字符，t里剩下的字符需要在s的剩下的字符里出现
    //      2. 不使用s[n-1]这个字符，那么就需要【在s[n-1]之前的字符里找到子序列等于t】
    //      综上，如果最后一位相同，那么方案数等于这两个可能之和
    // 如果它们最后一位不同，那么只有一种方案，在s[n-1]之前的字符串里找到子序列等于t
    // 定义dp[i][j]表示在s的前i个字符里，寻找子序列等于t的前j个字符
    // 可知dp[0][j] = 0, dp[i][0] = 1
    // 如果s[i - 1] == t[j - 1], 那么dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j]
    //      注意i和j表示第几个字符，所以索引需要-1
    //      第i个字符等于第j个字符，也就是s[i - 1] == t[j - 1]
    //      dp[i][j]是在s的前i个字符里找t的前j个字符，它等于两种可能之和
    // 如果s[i - 1] != t[j - 1], 那么dp[i][j] = dp[i - 1][j]
    //      同上，注意索引位置
    // 这道题的索引要注意，多处有索引偏移的问题

    public int numDistinct(String s, String t) {
        int n = s.length();
        int m = t.length();
        // 注意dp表示的是前几个字符，所以应当包含0到n和m，初始化容量要+1
        int[][] dp = new int[n+1][m+1];

        // 这两个for不能颠倒，因为要保证dp[0][0] = 1
        for (int j = 0; j <= m; j++) {
            dp[0][j] = 0;
        }
        for (int i = 0; i <= n; i++) {
            dp[i][0] = 1;
        }
        
        // 包含的字符数量从1到n和m
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= m; j++) {
                // 第i和和第j个字符，对应索引要-1
                if (s.charAt(i - 1) == t.charAt(j - 1)) {
                    dp[i][j] = dp[i-1][j-1] + dp[i-1][j];
                } else {
                    dp[i][j] = dp[i-1][j];
                }
            }
        }

        // 返回的是前n个字符里找前m个字符
        return dp[n][m];
    }
}
// @lc code=end

